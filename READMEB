A drop and go app to handle upload and display of images in Django.

This app is not intended to be 'powerful'. Thee base code is concise and levers Django recommentions and facilities wherever possible. It should form a good base for others wishing to build their own app.

The front end, by which I mean 'programmer API' is deesigned for a particular purpose (but most image apps aree). It is for webistes where images are targeted by title and associated with other models. Use cases might include websites of local interest, such as small-scale publishing and shops. These examples associate images with other models, for example, SalesItem or Article.

The app is designed for images, so of limited use for other documents and media. It won't be useful for a large number of images, for that you will need to abandon use of Django admin. It is also limited for use with a small numbers of images, because you may want more help with image previews and gallery handling. 

So far, I have not considrered,

- SVG images
- pormissions handling
- cloud storage.


# Depemdancies
Pillow
Unidecode

Optionally, the fron-end can work with other image librarties such as Wand and OpenCV.


# General structure
Images are tracked in the database. Each uploaded image is recorded by an entry in a database table ''image'. Each original image can generate derivivate images. These are tracked in a seperate table called ''reform'. Widths, heights and bytesize are recorded, in case the storage media is not local files but cloud provision.

File-based images are stored in media/ with paths adjustable through Django settings.

Reforms are generated by filters. Filters can be defined in apps or centrally. 

Image delivery is by template filters and tags. The presence of a filter and tag will generate the reform automatically. For eample, you define a filter called ''Large'. When you add template code,

    {% image Large urban_decay %} 

then visit the page, the app will generate a ''Large' reform to the spec given in the filter.

A few filters are predefined, (centre-anchored) Crop, Resize, and a SmartCrop. If you only need different image sizes, then you only need to configure these. But if you want to pass some time with image-processing code, you could add ''Chrome' and other similar filters.

The app also includes code to upload images, and a switch to deliver images through a URL.


# Init
You need,

    pip unidecode

[Unidecode](https://pypi.org/project/Unidecode/)

    pip pillow

[Pillow](https://pillow.readthedocs.io/en/stable/index.html)

Download the app code to Django

Declare in apps,

???

migrate now, or declare a field (see below) then migrate,

    ./manage.py makemigrations
    ./manage.py migrate


# Quickstart
## Fields and Upload
Pick an app. For illustration I'm going to call the app Page, but pick your own. In models.py,


    from image.models import Image


    class Page(models.Model):

        img = models.ForeignKey(
            'image.Image',
            null=True,
            blank=True,
            on_delete=models.CASCADE,
            related_name='+'
            )

         etc.

Sync the DB to the updated model,

    manage.py makemigrations
    manage.py migrate

Now, through Django admin, you can upload a image. Upload one and give it a title (you can delete too, so don't worry about getting other settings to your preference).
 
However, I don't know about you, if I have a new app I'd like to try with some substancial data. If you have a collection of test images somewhere,

    ./manage.py image_create_bulk pathToMyDirectory


## Viewing images
Ok, lets show an image. In the same app, goto a template, I'll assume you are passing the model in through the context. Add this, 

        {{ image-tag image.Large page.img }}
        <caption>{{ page.img.title }}</caption>

That's it. Refresh the server and browser and you should see the image. To change how the image is filtered, size and so on, see Filters.





# Further
Model field declaration is by foreign key. 

With the image app you do most of your work in the app which uses the images, not the app itself.


## Filters
### Filter placement
Files of filter definitions can be placed in any app. Start a file called 'image_filters.py' and off you go.

This works for me---inside an app called Page I can have a file of filters e.g. Large/Medium/Small, made for Page styling. Inside an app called BlogPost, another set of filters Medium/Small/Thumb made for BlogPost styling.

If you would prefer to gether all filters together in one place, define the settings to include,
 
            'MODULES': [
                        "someSiteName",
            ],

Then put a file in the 'sitename' directory. If you do this, you will probably need to namespace filters,

    BlogPostLarge:
        width : 256
        height 256



### Writing Filters
Most of the filters you will need can be made by inheriting from the core filters in the app. There are,

- Resize
- Crop

Both these fit the image within the bounding box given by the dimansions. Both fiters can result in images narrower or less in height than the given sizes.

Two more filters,

- SmartResize 
- SmartCrop. 

These filters fill out their results by placing on a background of given color so the results always match the given dimensions. Also, they will not attempt to work on images that are smaller than the bounding sizes.

If you are inheriting from these filters, it's easy to produce another size. Put this in an 'image_filters.py' file somewhere,

   from image import filters

   class Large(filters.SmartResize):
        width=382
        height=256



### Writing custom filter code
Inherit from image.Filter. You will need to provide a 'process' method. Filter takes an open Python File and returns a ByteBufferIO and a filename. You can inherit from the PillowMixin or WandMixin to cover filehandling for those libraries. See the code for details.


### Why can filters not be chained?
Filters can not be chained, and there is no way to do that or present chaining to a user. Filters must be written in code, and do not accept parameters. You want a new resize filter, you write it.

This is a deliberate decision. It makes life easy. If you want to produce a front-end that can lever the filters and chain them, that is another step. Possible, but further than this app will go.




## Admin
The model has auto-slug() code. Declare this in admin.py to fill in suggestions automatically,

    class PageAdmin(admin.ModelAdmin):
        prepopulated_fields = {'slug': ('title')}



## Management commands
There are these

image_create_bulk
image_sync
reform_delete

They do what they say. 'image_sync' is particularly useful, it will attemt to make models for orphane files, delete orphaned files, or delete models with missing files.

 
## Template tags
There is a tag to find images by title. Sometimes this will be useful, for fixed or temporary decoration/banners etc. However, it is a database hit, unecessary if you are passing a model through a context,

        {{ image-tag-by-title image.Large titleOfImage }}
        <caption>{{ page.img,title }}</caption>



## Settings
Images accepts some settings. They look like the Django template settings,

    IMAGES = [
        {
            'APP_DIRS': True,
            # 'MEDIA_SUBPATH_ORIGINALS':
            # 'MEDIA_SUBPATH_REFORMS':
            'TRUNCATE_PATHS' : True,
            'MODULES': [
                        "someSiteName",
            ],
        },
    ]

APP_DIRS
Defines if image_filters will be sought in apps. If false, the app only uses filters defined in the core app.

TRUNCATE_PATHS
Truncate filepaths. This is usually done by truncating the length of filenames (which can become very long on the web). This is because Django imposes limits on filepath lengths.

MODULES
Defines extra places to put modules. The above example suggests a site-wide filter collection in the site directory, same as the site-wide template collection most Djangos have in the same directory. The setting takes module paths, not filepaths, because filter files are live code.

# Other usages
 but for resons of ecomomy, Django doessn't automatically use full clean.. This to thoroughtly check the slug in a 

 So maybe a DetailView,

    class ArticleDetailView(DetailView):
        model = Article
        context_object_name = 'article'
        
Then, it's a waste of the Wagtail setup, but you can summon the original in a template  as simply as,

        {{ article.img.img_tag }}
        <caption>{{ article.img,title }}</caption>

# Types of image
No SVG. Pillow can't pass them over.




# Credits
I take little credit for the upload and storage code. It was ripped from the Wagtail CMS. Though I have responsibility for how I have treated the code.

[Wagtail documentation](https://docs.wagtail.io/en/v2.8.1/advanced_topics/images/index.html)
