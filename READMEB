# Django-images
A drop and go app (as much as a Django app can be) to handle upload and display of images in Django.

The base code is concise and levers Django recommentions and facilities where possible. It may form a good base for others wishing to build their own app.

The front end, by which I mean 'programmer API' is designed for a particular purpose (most image apps are). It is for webistes where images are associated with other models. Use cases might include websites of local interest, such as small-scale publishing and shops. These examples would associate images with other models, for example, SalesItem or Article.


## Why you may not want this app
This may not be the app for you.

<div style="border:1px solid blue; background-clor:cornsilk;"><
*Info*: The app API does not let you write template tags with adjustable parameters, filters with runtime parameter processing, create filter chains, or categorise/tag images.
</div>

All these facilities can be built in to the base code. But then the app wil not be, for you, a plug and go solution.
 
The code API is a step back from the facilities mentioned above. It is small, concise, and fits good CSS/template-practice. Also, so far, I have not considered and/or tested,

- SVG images
- pormissions
- cloud storage


# Overview
Images are tracked in the database. The base table is called ''image'. 

Each original image can generate derivitive images. These are tracked in a table called ''reform'. Reforms are generated by filters. Filters can be defined in apps or centrally. 

Image delivery is by template tag. The presence of a tag with a reference to an image and a filter will generate a reform automatically. The tags deliver images by URL.

File-based storage is in 'media/' with paths adjustable through attribute settings.

The app includes code to upload images. The Django admin for the base application has some (optional) light customisation.


# Quickstart
## Depemdancies
Unidecode,

    pip unidecode

[Unidecode](https://pypi.org/project/Unidecode/)

Pillow,

    pip pillow

[Pillow](https://pillow.readthedocs.io/en/stable/index.html)


### Optional
The code API can work with other image libraries such as Wand and OpenCV. Some Wand filters are built-in. On Debian-based distros,

    sudo apt-get install libmagickwand-dev

Then,

    pip install wand

The built-in Wand filters offer more image-processing options.



## Install
Download the app code to Django

Declare in Django settings,

        INSTALLED_APPS = [
            ...
            'image.apps.ImageConfig',
            ...
        ]

migrate now,

    ./manage.py makemigrations image
    ./manage.py migrate image

If you have Django Admin, you can now upload images.



## Uploading
In Django admin, go to Image upload and try upload a few images.

I don't know about you, but if I have a new app I like to try with real data. If you have a collection of test images somewhere, try this management command,

    ./manage.py image_create_bulk pathToMyDirectory

You can create, meaning upload and register, fifteen or twenty images in a few seconds.



## Viewing images
Ok, let's see an image, as you would on site. Two ways.

### Via a view 
Find a web view template. Nearly any template will do (maybe not a JSON REST interface, something visible).

Add this tag to the template,

    {% load img_tags %}
    ...
    {% imagequery "pk=1" image.Thumb %}

'image.Thumb' is a predefined filter, the only one the app contains. It makes a 64x64 pixel Thumbnail. The tag we use here searchs for an image by a very low method, "pk=1". This will do for now.  

Visit the page. The app will generate the filtered 'reform' image automatically, To change how the image is filtered, size and so on, see Filters.


### Don't have a view?
Yeh, new or experimental site, I know. Image has a builtin view. Goto urls.py, add this,

    path('image/<int:pk>/', ImageDetailView.as_view(), name='image-detail'),

Now visit (probably),

    http://localhost:8000/image/1/

To see some *real* web code.


## Filters
Perhaps your firat request will be how to make a new filter. So, a deviation.

Make a new file called 'image filters'. Put it in the top level of any app, or in the site folder (alongside url.py and wsgi.py). Put something in it like this (adapt if you wish),

    from image import Resize, registry

    class MediumImage(Resize)
        width=260
        height=350
        format='png'

    registry.register(MediumImage)
 
Now adapt the template tag (or the tag in image/templates/image/image_detail.html) to point at the new filter,

    {% imagequery "pk=1" someAppName.MediumImage %}

Visit the page again. Image sees the new filter definition, finds it has no record of a reform for that image and filter, so generates a new one, then displays it.

Ok, you changed the image size, and maybe the format. If you want to continue, you probably have questions. Goto the main documentation.



# QuickStop
Don't like what you see?

Remove any temporary code.

Migrate backwards,

    ./mangage.py migrate image zero

Remove from apps.py.

Remove the two directories in /media,

    originals/
    reforms/

Remove the app folder.

That's it, gone.


# Full documentation
The documenation is split into general areas. 

- Attaching images to models
- Creating other tables
- Filters
- Viewing images
- Uploading
- Settings

- Aministration support


## Attaching images to models, creating other tables
### Quickstart
Pick an app. Maybe you have a test app? For illustration I'm going to call the app Page, but pick your own. In models.py, add this field,


    from image.model_fields import SingleImage


    class Page(models.Model):

        img = SingleImage(
            null=True,
            blank=True,
            on_delete=models.CASCADE,
            related_name='+'
            )

         etc.

Migrate, then have a go at viewing the admin and uploading images (since this field is set to accept blank entries, it should cause no problems in migration).

The image data will be passed to views through the context so, within the app templates, you can refer to the images using this tag,

        {% image image.Thumb page.img %}

You will note the tag is called 'image', not 'imagequery'. image.thumb refers to the stock filter. page.img refers to the context passed to the view.

The 'image' tag avoids the extra database hit of 'imagequery', and can flex to different models.


### Creating Image fields
#### The SingleImage model field
Works from OneToOne field, so can only handle one unique image (presumably an image attached to a model, e.g. a lead image for an Article),

    from image.model_fields import SingleImage


    class Page(models.Model):

        img = SingleImage(
            null=True,
            blank=True,
            on_delete=models.CASCADE,
            related_name='+'
            )

#### Stock Django declaration,
You can also use a stock Django foreign key declaration,

    from image.models import Image


    class Page(models.Model):

        img = models.ForeignKey(
            'image.Image',
            null=True,
            blank=True,
            on_delete=models.CASCADE,
            related_name='+'
            )

         etc.

### Chossing between the two
Which you prefer depends on what you find explicit, maintainable, concise, and so forth. SingleImage is little more than a rename, and only validates that it is a filefield. However, you will need to use SingleImage if you wish to try the builtin admin. By renaming the field, the app namespaces itself away from doing anything unexpected with the admin.

Then again, the stock Django declartion is slightly more flexible, you could use other model.fields such as ManyToOne.


#### File deletion and other settings
The above settings will remove images when the model is deleted. If you prefer,

 img = models.ForeignKey(
        'image.Image',
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
        related_name='+'
    )

will leave images in storage and the models on the db. 

Also, null=True and blank=True means you can delay adding an image until later. And related_name='*' means that Images will not start tracking the model you are creating. Se Django documentation of model fields for more details.


## Creating new Image-handling tables
Image is equipped, and it is expected, that you will create new models from the base models. New image models have new DB tables, new upload folders and can have different configuration.

Two scenarios where you may want to do this,

### Extend data associated with images
There is a lot of extra data you may want to associate with an image. 

Many people's first thought would be a title. That said, a title is often not displayed, and/or a simple duplication of a filename, which should be avoided. That's why Image does not provide titles by default.

But other kinds of information can be attached such as captions, credits, dates, and/or data for semantic rendering. All of these can legitimately viewed as 'part of the image' or 'an aspect of the image'.

### Splitting needs
Its fun to tweak with settings, but sometimes, maybe often, this is not the best approach.

Let's say you have a website which gathers photos that are joined to NewsArticle. Those photos are linked for sure to the Article, and can probably be created and deleted with the NewsArticle. They may also need license, credit, extra date, caption and semantic text fields.

But you may also have a need to upload images for the site in general. Perhaps for banner displays. This is an image pool. The deletion policy is different. There may be no need for credits.
 
These are two seperate apps. Make two apps. Avoid complex configuration.

## Creating new tables
In an app, do this. 

    from image.models import AbstractImage, AbstractReform

    class NewssArticleImage(AbstractImage):
        upload_dir='news_originals'
        filepath_length=100

        # AbstractImage has a file and upload_date
        caption = models.CharField(_('Caption'),
            max_length=255,
        )

        author = models.CharField(_('Author'),
            max_length=255,
            db_index=True
        )

        etc.



    class NewssArticleReform(AbstractReform):
        upload_dir='news_reforms'
        filepath_length=100

        image = models.ForeignKey(NewssArticleImage, on_delete=models.CASCADE, related_name='reforms')

Sorry it's not the last word in DRY coding, but you should be able to work out what the code is there for. Note the two configuration variables. Useful. Think about them before you migrate.

Then migrate,

    ./manage.py migrate NewsArticle

You now have a new image upload app. It has it's own DB tables. Change it's configuration. Refer to it in the models,

    class NewsArticle(models.Model):

        img = SingleImage(
            "image.NewssArticleImage"
            null=True,
            blank=True,
            on_delete=models.CASCADE,
            related_name='+'
            )

        etc.

### Things to do with subcalsses of models

You may want to configure a Meta. If you have titles or slugs, for example, you may be interested in making them into unique constrained groups or adding indexes,

    class NewssArticleImage(AbstractImage):
        upload_dir='news_originals'
        filepath_length=100

        etc.

        class Meta:
            verbose_name = _('news_image')
            verbose_name_plural = _('news_images')
            indexes = [
                models.Index(fields=['author']),
            ]
            constraints = [
                models.UniqueConstraint(
                    fields=['title', 'author'], 
                    name='unique_newsarticle_reform_src'
                )



## Filters
### Overview
Filters are used to describe how an original uploaded image should be modified for display. In the background, the app will automatically adjust the image to the given spacification (or use a cached version).
 
A few filters are predefined. These are base filters, which you configure. They are (centre-anchored) Crop, Resize, SmartCrop, SmartResize. If you only need different image sizes, then you only need to configure these. But if you want to pass some time with image-processing code, you can add extra filters to generate ''PuddingColour' and other filters.


### Filter declarations
All builtin filter bases accept these attributes,

    width
    height
    format

Most filter code demands width and height, but format is optional. Without a stated format, the image stays as it was (unless an overall setting is in place). formats accepted are,

    gif, png, jpg, bmp, tiff, webp 

which should be written as above (lowercase, and 'jpg', not 'jpeg'). So,

    from image import Resize, registry

    class MediumImage(Resize)
        width=260
        height=350
        format='png'

    registry.register(MediumImage)


Crop and Resize can/often result in images narrower in one dimension. 

The Smart variations do a background fill in a chosen colour, so return the requaeted size,

    from image import ResizeSmart, registry

    class MediumImage(ResizeSmart):
        width=260
        height=350
        format='jpg'
        fill_color="Coral"

    registry.register(MediumImage)

Fill color is defined however the image library handles it. Both Pillow and Wand can handle CSS style hex e.g. '#00FF00' (green), and HTML colour-names e.g. 'AliceWhite'.


### Filter placement and registration
Files of filter definitions can be placed in any app. Start a file called 'image_filters.py' and off you go.

If you would prefer to gether all filters together in one place, define the settings to include,

    Image : {
            'MODULES': [
                        "siteName",
            ],
    }

Then put a file image_filters.py in the 'sitename' directory. If you do this, you will probably need to namespace filters,

    BlogPostLarge:
        width : 256
        height 256


### Registering filters
Filters need to be registered. The style is like a ModelAdmin. Registration is to the image.registry (this is how templatetags finds them).

You can use the declaration used in the examples above,

    from image import ResizeSmart, registry

    ...

    registry.register(single_or_list_of_filters)

There is also (like ModelAdmin) a decorator available,

    from image import register, ResizeSmart

    @register()
    class MediumImage(ResizeSmart):
        width=260
        height=350
        format='jpg'
        fill_color="Coral"


### Wand filters
The base filters in the Wand filter set have more attributes available. The module needs Wand to be installed on the host computer, and a deliberate import. Assuming that, you gain these extra effects on every Wand filter,

    from image import registry
    from image.wand_filters import ResizeSmart

    class MediumImage(ResizeSmart):
        width=260
        height=350
        format='jpg'
        pop=False
        greyscale=False
        night=False
        warm=False
        strong=False
        no=False
        watermark=None # e.g.'/srv/images/watermark.png'

    registry.register(Medium)


If you enable more than one effect, they will chain, though you have no control over order.

I lost my way with the Wand effects. There is no 'blur', no 'rotate', no 'waves'. But there is,

pop
    Tightens leveling of black and white
greyscale
    A fast imitation
night
    Pretend the picture is from a movie
warm
    A small shift in hue to compensate for a common photography white-balance issue. 
strong
    Oversaturate image colors (like everyone does on the web). Unlike 'pop' this will not stress contrast so flatten blacks and whites. You may or may not prefer this. 
no
    Draw a red cross across the image
watermark
    Accepts a filepath to a watermark image template.

Watermark deserves some explanation. This does not draw on the image, as text metrics are tricky to handle. Provide a URL stub to an image, here's a builtin,

    watermark = 'image/watermark.png'

The URL is Django static-aware, but will pass untouched if you give it a web URL (like the URLs in Django Media).
 
The template is scaled to the image-to-be-watermarked, then composited over the main image by 'disolve'. So the watermark is customisable, can be used on most sizes of image, and is usually readable since aspect ratio is preserved.

It is probably worth saying again that you can not change the parameters, so the strengths of these effects, without creating a new filter.


### Writing Filters
Most of the filters you will need can be made by inheriting from the core filters. All core filters aree enabled in Pillow and Wand. The core/base filters are,

- Resize
- Crop

 Both these fit the image within the bounding box given by the dimensions. Both filters can result in images narrower or less in height than the given sizes.

Two more core filters,

- SmartResize 
- SmartCrop

These filters fill the bounding box by placing on a background of a given color so the results match the given dimensions. Also, they will not attempt to work on images which are smaller than the bounding sizes. They center the image in the fill color.

By inheriting from these filters, you can configure them to the sizes you need.


### Writing custom filter code
First bear in mind that Image uses fixed parameters. So your filter must work with fixed parameters across a broad range of uploaded images. I don't want anyone to dive into code, put in hours of work, then ask me how they can create an online image-editing app. Not going to happen.

However, while I can't make a case for 'waves' or 'pudding-colour' filters, I can see uses. For example, Wagtail CMS uses the OpenCV library to generate images that auto-focus on facial imagry (i.e. not centrally crop). There are uses for that.

Second, bear in mind that image editing is lunging into another world, rather like creating Django forms without using models and classes. It will take time. But there is help available.
 
Inherit from image.Filter. You will need to provide a 'process' method, which takes an open Python File and returns a ByteBufferIO and a file extension.

If you want the filter to work with the Pillow or Wand liraries, you can inherit from the PillowMixin or WandMixin. These cover filehandling for those libraries. so you can provide a 'modify' method, which alters then returns an image in the format of those libraries.

See the code for details.


### Why can filters not be chained?
Filters can not be chained dynamically. There is no way to present chaining to a user. You need to create a fixed filter. Filters must be written in code, and do not accept parameters. You want a filter with new parameters, you write it and it is set.

This is a deliberate decision. It makes life easy. If you want to produce a front-end that can lever the filters and chain them, that is another step. This is not that app.





# Admin
## Overview
Image ships with stock Django admin.

However, this is not always well-suited to the app, or intended or possible uses. So there are some adittions.

## Built-in solutions
### Main admin
If you go to the admin.py file in the app, you will find an alternative Admin file builtin. This is for handling the images and image DB itself (not images attached to models in other apps),

    # Custom admin interface disalows deletion of files from models.
    #class ImageAdmin(ImageLockedAdmin):
        
    # Stock admin interface.
    class ImageAdmin(admin.ModelAdmin):
        pass
            
            
    admin.site.register(Image, ImageAdmin)

If you'd like to try the modified app, change the comments,

    # Custom admin interface disalows deletion of files from models.
    class ImageAdmin(ImageLockedAdmin):
        
    # Stock admin interface.
    #class ImageAdmin(admin.ModelAdmin):
        pass
        
        
    admin.site.register(Image, ImageAdmin)

The modified app makes several changes to the builtin Admin. A short list of significant changes,

- changelist is tidier and includes view links
- changelist has searchable titles
- upload form prepopulates the new title with the filename 
- change form disables Image choice

### For model links

## Parts available
The prebuilt packages above rely on several pieces of code, which you can use yourself. But using them yourself may involve some thought. 

For example, the prepopulate code is somethig Django users sometimes ask about. The standard Django.form prepopulate() will not work away from slug fields, especially for widgets as complex as a File browser. But it works here? Because it uses a Javascript modification of the Django Admin code. So to use it in your own Admin, you need to add a Media class, and declare model fields as SingleImage. 

So integrating one part of the functionality of these packages may not be as easy as you think. If you want to do that, go look in admins.py, where the code is gathered and heavily commented.


### The ModelShowField > RemoteControlWidget chain
Worth mentioning. The included packages don't use it, but it is in the app for possible use. A picture is sometimes worth a lot,

@img

The ModelShowField > RemoteControlWidget chain takes a foriegn key field, traces it, then displays info on the linked object, and configurably, links to editing it.

Consider when to use this field/widget. Furst, it is not possible to edit the link between the main model and the linked model. Django contrib.Admin allows you to do this, indeed, it is impossible to turn off. But, sometimes, you do not want to edit the link.

Second, the display is an easy-to-undertand flat link between edit pages. 

Third the field has no need to do a big database hit to discover potential images. Only one small hit for the linked object (which may well be cached). And the widget does not use a Select box, so in several situations will scale better then the usual admin (unless one field links to hundreds of images).

So, consider.if you find yourself wanting a neww data structure, don't mess with configuration, make a new instance of the model.





###################################
Images are made available in admin. Reforms are not (they autogenerate from template tags, autodelete their files, and are generally regarded as automatic).

Images are mainly intended to be attached to other models. So the admin display is only intended for dev and maintencence. Therefore the displays are basic, and will not display images, to speed lookups and save visual space.

The model admin forms have prepopulate code for titles. If you don't want that, comment out the prepopulate attribute, and preferably the media property declaration.



### Management commands
They are,

- image_create_bulk
- image_sync
- image_list
- reform_delete

They do what they say. 'image_sync' is particularly useful, it will attempt to make models for orphaned files, or delete orphaned files, or delete models with missing files. All of these actions are useful for dev, too.

 
## Template tags
For example, you define a filter called ''Large'. When you add template code,

    {% image report.img my_app.Large %}
 
then visit the page, the app will generate a ''Large' reform to the spec given in the filter.

The tag guess can guess the app from the context. So,

     {% image report.img Large %}

Will assume the filter is in the app the context says the view comes from.

The tag accpts keyword parameters which become HTML attributes,

     {% image report.img Large class="report-image" %}
     <caption>{{ page.img.title }}</caption>

Assuming a title "End Of Year Table", this renders similar to,

    <img src="/media/reforms/eoy-report_large.png" alt="end of year table image" class="report-image">
    <caption>End Of Year Table</caption>


### Data search by title
There is a tag to find images by title. Sometimes this will be useful, for fixed or temporary decoration/banners etc. 

        {{ imagefromtitle "titleOfImage" image.Large  }}

However, it uses a database query. While this may be useful at times, especially for fixed logos or banners, it is unnecessary if you are passing a model through a context,


### Filters from other apps
You can borrow filter collections from other apps. Use the module path and filter classname,

    {% image "urban_decay" different_app.filter_name  %} 

But try not to create a tangle between your apps. You would not do that with CSS or other similar resources. Store general filters in a central location, and namespace them.


## Settings
Images accepts settings. They look like the Django template settings,

    IMAGES = [
        {
            #'MAX_UPLOAD_SIZE': 1,
            'APP_DIRS': True,
        'AUTO_DELETE': True,
        'REFORMS': [
            #'FORMAT_OVERRIDE': 'jpg',
            #'JPEG_QUALITY': 28,

        ],
            'MODULES': [
                        "someSiteName",
            ],
        },
    ]


### General settings
MAX_UPLOAD_SIZE
If not set or None, any size allowed. In MB. Fractions allowed.

APP_DIRS
Defines if 'image_filters.py' files will be sought in apps. If false, the app only uses filters defined in the core app.

MODULES
Defines extra places to put modules. The above example suggests a site-wide filter collection in the site directory, same as the site-wide template and CSS collections most Djangos have in the same directory. The setting takes module paths, not filepaths, because filter files are live code.

AUTO_DELETE
When Django started, AFAIK, when models were deleted, attached files were deleted. But default strategy has changed, and now Django will not delete files. They stay in storage, even if untracked.

Deleting files when the model is deleted has downsides, but suits the use-cases of this app. The default of this app is like Django, it will not delete files. But this setting allows you to use clean-on-delete.

You may have noticed in Admin that the app offers a switch to set policy by image. Local settings win---the per-image setting overrides the general setting. For example, you may decide to generally erase files when models are deleted. But if you want to set an image against deletion---for example, a banner, a logo or a generic product photo---you can set that image to persist.


### Reform settings
FORMAT_OVERRIDE
Set a preferred image format. Locality wins. If a filter sets an 'iformat' attribute, that wins. After, if this site-wide setting is present, it wins. After, the filter will attempt to make the file in whatever format it originally detected.

JPEG_QUALITY
Quality of reform JPGs. Basic is '85' of '100', which is high quality. You can go down to '28', say, and get a vast reduction in file sizes.

Locality wins. If a filter sets a 'jpeg_quality' attribute, that wins. After, if this site-wide setting is present, it wins. Otherwise, the quality defaults to '85'.




# Other usages
 but for resons of ecomomy, Django doesn't automatically use full clean.. This to thoroughtly check the slug in a 

 So maybe a DetailView,

    class ArticleDetailView(DetailView):
        model = Article
        context_object_name = 'article'
        
Then, it's a waste of the Wagtail setup, but you can summon the original in a template  as simply as,

        {{ article.img.img_tag }}
        <caption>{{ article.img,title }}</caption>

# Types of image
No SVG. Pillow can't pass them over.

 Widths, heights and bytesize of original images are recorded, in case the storage media is not local files but cloud provision.


## Templated HTML and URLs/Filepaths
The app uses the URL attribute of the FileFields to generate HTML 'src' (not the filepath). So it should keep working if you swap storage backends or, at least, keep responding an a Django-like way.


## Forms
There's nothing special about using the Image model in forms. Stock Django. Use the model via Django admin or Model forms. For your own forms, the Image model contains some extra validators, but a call to is_valid() will run them.


## Models
There's a helper for model fields. It's a small override of a OneToOneField,

ImageSingleField
    A preconfigured model field for Images.
    This is a OneToOneField, so not suitable for referring to several 
    images e.g gallery use. Also, becaue OneToOneField, once it has an
    image no other model in that table can share the image 
    (unique=True). Mainly intended for images coupled to models e.g
    'Sales product' -> 'Product image'.
    Mild configuration to delete image if model is deleted, and
    not to be able to track the image back to the model (the model
    can find it's image, though). 

e.g.

    class Page(models.Model):

        img = image.ImageSingleField(
            'image.Image',
            null=True, 
            blank=True,
        )


## Utilities
### The View
Image has a builtin view. It's main purpose is to test filter code. The view reforms from images in the core folder. As a test and trial device, it is not enabled by default.

Goto urls.py, add this,

    path('image/<int:pk>/', ImageDetailView.as_view(), name='image-detail'),

Now visit (probably),

    http://localhost:8000/image/1/

The template is at,

    image/templates/image/image_detail.html

Where you can edit the template tag to point at your own configurations. With visible results and basic image data, it is a lot easier to use than the shell.


# Credits
I take little credit for the upload and storage code. It was ripped from the Wagtail CMS. Though I have responsibility for how I have treated the code.

[Wagtail documentation](https://docs.wagtail.io/en/v2.8.1/advanced_topics/images/index.html)




##############
I think the best way to say this is that this app not intended to be 'powerful'. 

The app is designed for images, so of limited use for other documents and media. It won't be useful for a large number of images, for that you will need to abandon use of Django admin. It is limited for use with a small numbers of images, because you may want more help with image previews and gallery handling. It can not be used to offer users image processing options.


############################################

# Full notes

With the image app you do most of your work in the app which uses the images, not the app itself.

<div style="background-color=pink; border:1px solid red;"><
*Warning*: This app does not let you write filters with parameters other than a filter name into templates.
/div>

You write a filter, then reference it in templates. It's easier this way, and why would you write variable into templates any more than you would hard-set inline CSS? I tell you this now, in case this app, in it's basic state, is not for you.




This works for me---inside an app called Page I can have a file of filters e.g. Large/Medium/Small, made for Page styling. Inside an app called BlogPost, I can place another set of filters Medium/Small/Thumb, made for BlogPost styling.

Put this in an 'image_filters.py' file somewhere,

   from image import filters

   class Large(filters.SmartResize):
        width=382
        height=256
        # optional. By default, 'white'
        background_colour="#34578"
        # optional. By default, the format of the source.
        iformat='png'

###########
https://github.com/ebertti/django-admin-easy/blob/master/README.rst

https://pypi.org/project/django-reverse-admin/#modal-close
