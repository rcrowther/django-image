# Django-images
A drop and go app to handle upload and display of images in Django.

The base code is concise and levers Django recommentions and facilities when possible. It may form a good base for others wishing to build their own app.

The front end, by which I mean 'programmer API' is designed for a particular purpose (most image apps are). It is for webistes where images are targeted by title and associated with other models. Use cases might include websites of local interest, such as small-scale publishing and shops. These examples would associate images with other models, for example, SalesItem or Article.


## A step back
This may not be the app for you.

<div style="border:1px solid grey;"><
*Info*: This app API does not let you write template tags with adjustable parameters, filters with runtime parameter processing, create filter chains, or categorise/tag images. Also, it has no predefined permissions.
</div>

All these facilities can be built into the base code. But then the app wil not be, for you, a plug and go solution.
 
I think the best way to say this is that this app not intended to be 'powerful'. The code API is a step back from the facilities mentioned above. It is small, concise, and fits in with good CSS/template-practice. Also, so far, I have not considered and/or tested,

- SVG images
- pormissions
- cloud storage


# Depemdancies
Unidecode,

    pip unidecode

[Unidecode](https://pypi.org/project/Unidecode/)

Pillow,

    pip pillow

[Pillow](https://pillow.readthedocs.io/en/stable/index.html)


## Optional
The code API can work with other image libraries such as Wand and OpenCV. Some Wand filters are built-in. On Debian-based distros,

    sudo apt-get install libmagickwand-dev

Then,

    pip install wand

The built-in Wand filters offer a few more image-processing options.


# General structure
Images are tracked in the database. The table is called ''image'. Each original image can generate derivitive images. These are tracked in a table called ''reform'.

File-based storage is in media/ with paths adjustable through Django settings.

Reforms are generated by filters. Filters can be defined in apps or centrally. 

Image delivery is by template tags. The presence of a filter and tag will generate the reform automatically, when needed. 

The app also includes code to upload images, and a switch to deliver images through a URL.


# Init
Install dependencies.

Download the app code to Django

Declare in Django settings,

        INSTALLED_APPS = [
            ...
            'image.apps.ImageConfig',
            ...
        ]

migrate now, or declare a field (see below) then migrate,

    ./manage.py makemigrations
    ./manage.py migrate

If you have Django Admin, you can now upload images.


# Quickstart (fast as Django can)
## Fields and Upload
Pick an app. For illustration I'm going to call the app Page, but pick your own. In models.py,


    from image.models import Image


    class Page(models.Model):

        img = models.ForeignKey(
            'image.Image',
            null=True,
            blank=True,
            on_delete=models.CASCADE,
            related_name='+'
            )

         etc.

That would remove images when the model is deletd.  Null=True and blank=True means you can delay adding an image until later. Or maybe you want to ,

 img = models.ForeignKey(
        'image.Image',
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
        related_name='+'
    )

will leave images in storage and on the db. related_name='*' means that Images will not start tracking the model you are creating.

Sync the DB to the updated model,

    manage.py makemigrations
    manage.py migrate

Now, through Django admin, when you make a new model you can also upload a image. You can easily delete and reattach images, so don't worry about getting other settings to your preference. The image title will autofill. 
 
However, I don't know about you, if I have a new app I like to try with real data. If you have a collection of test images somewhere, try,

    ./manage.py image_create_bulk pathToMyDirectory


## Viewing images
Ok, lets show an image. In the same app, goto a template, I'll assume you are passing the model in through the context. Add this, 

        {{ image-tag image.Large page.img }}
        <caption>{{ page.img.title }}</caption>

'image.Large' is a predefined filter. Te code will generate the image from the given title, then you should see the result onscreen. To change how the image is filtered, size and so on, see Filters.





# Full notes
Model field declaration is by foreign key. 

With the image app you do most of your work in the app which uses the images, not the app itself.

<div style="background-color=pink; border:1px solid red;"><
*Warning*: This app does not let you write filters with parameters other than a filter name into templates.
/div>

You write a filter, then reference it in templates. It's easier this way, and why would you write variable into templates any more than you would hard-set inline CSS? I tell you this now, in case this app, in it's basic state, is not for you.


## Filters
A few filters are predefined, (centre-anchored) Crop, Resize, SmartCrop, SmartResize. If you only need different image sizes, then you only need to configure these. But if you want to pass some time with image-processing code, you could add ''Chrome' and other similar filters.

### Filter declarations
All builtin filters accept these attributes,

    from image import Resize, registry

    class MediumImage(Resize)
        width=260
        height=350
        format='png'

    registry.register(MediumImage)


Crop and Resize can/often result in images narrower in one dimension. 

The Smart variations do a background fill in a chosen colour, so return the requaeted size,

    from image import ResizeSmart, registry

    class MediumImage(ResizeSmart):
        width=260
        height=350
        format='jpg'
        fill_color="Coral"

    registry.register(MediumImage)

Fill color is defined however the image library handles it. Both Pillow and Wand can handle CSS style hex '#00FF00' (green), and X-window/HTML colour-names 'AliceWhite'.


### Filter placement
Files of filter definitions can be placed in any app. Start a file called 'image_filters.py' and off you go.

This works for me---inside an app called Page I can have a file of filters e.g. Large/Medium/Small, made for Page styling. Inside an app called BlogPost, I can place another set of filters Medium/Small/Thumb, made for BlogPost styling.

If you would prefer to gether all filters together in one place, define the settings to include,

    Image : {
            'MODULES': [
                        "siteName",
            ],
    }

Then put a file in the 'sitename' directory. If you do this, you will probably need to namespace filters,

    BlogPostLarge:
        width : 256
        height 256

### Registering filters
All filters need to be registered in the image.registry (this is how the templatetag finds them).

You can use the simple declaration used in the examples above,

    from image import ResizeSmart, registry

    ...

    registry.register(single_or_list_of_filters)

There is also (like ModelAdmin) a decorator available,

    from image import register, ResizeSmart

    @register()
    class MediumImage(ResizeSmart):
        width=260
        height=350
        format='jpg'
        fill_color="Coral"


### Wand filters
The base filters in the Wand filter set have more attributes available. The module needs a deliberate import. So, and displaying the extra attribute,

    from image import registry
    from image.wand_filters import ResizeSmart

    class MediumImage(ResizeSmart):
        width=260
        height=350
        format='jpg'
        pop = False
        greyscale=False
        night= False
        warm = False
        strong = False
        no = False
        watermark = None #'/srv/images/watermark.png'

    registry.register(Medium)


The effects are available on every Wand filter. If you enable more than one effect, they will chain, though you have no control over that.

I lost my way with the Wand effects. There is no 'blur', no 'rotate', no 'waves'. There is,

pop
    Tightens leveling of black and white
greyscale
    A fast imitation
night
    Pretend the picture is from a movie
warm
    A small shift in hue to compensate for a common photography white-balance issue. 
strong
    Oversaturate image colors (like everyone does on the web). Unlike 'pop' this will not stress contrast so flatten blacks and whites. You may or may not prefer this. 
no
    Draw a red cross across the image
watermark
    Accepts a filepath to a watermark image template.

Watermark deserves some explanation. This does not draw on the image, as handling text metrics is unreliable. You provide a filepath to a image template,

    watermark = '/www/data/images/watermark.png'

The template is scaled to the image-to-be-watermarked, then compsited over the main image by 'disolve'. So the watermark is customisable, can be used on most sizes of image, and is usually readale since aspect ratio is preserved, 

It is probably worth saying again that you can not change the parameters, the strengths of these effects, without creating a new filter.


### Writing Filters
Most of the filters you will need can be made by inheriting from the core filters in the app. There are,

- Resize
- Crop

Both these fit the image within the bounding box given by the dimansions. Both filters can result in images narrower or less in height than the given sizes.

Two more core filters,

- SmartResize 
- SmartCrop

These filters fill the bounding box by placing on a background of a given color so the results match the given dimensions. Also, they will not attempt to work on images which are smaller than the bounding sizes. They center the image in the fill color.

By inheriting from these filters, you can configure them to the sizes you need. Put this in an 'image_filters.py' file somewhere,

   from image import filters

   class Large(filters.SmartResize):
        width=382
        height=256
        # optional. By default, 'white'
        background_colour="#34578"
        # optional. By default, the format of the source.
        iformat='png'


### Writing custom filter code
Inherit from image.Filter. You will need to provide a 'process' method. Filter.process() which takes an open Python File and returns a ByteBufferIO and a filename.

You can inherit from the PillowMixin or WandMixin to cover filehandling for those libraries. See the code for details.


### Why can filters not be chained?
Filters can not be chained, and there is no way to do that or present chaining to a user. Filters must be written in code, and do not accept parameters. You want a new size filter, you write it.

This is a deliberate decision. It makes life easy. If you want to produce a front-end that can lever the filters and chain them, that is another step. Possible, but further than this app will go.





## Admin
The model has auto-slug() code. Declare this in admin.py to fill in suggestions automatically,

    class PageAdmin(admin.ModelAdmin):
        prepopulated_fields = {'slug': ('title')}



## Management commands
They are,

- image_create_bulk
- image_sync
- image_list
- reform_delete

They do what they say. 'image_sync' is particularly useful, it will attempt to make models for orphaned files, or delete orphaned files, or delete models with missing files. All of these actions are useful for dev, too.

 
## Template tags
For example, you define a filter called ''Large'. When you add template code,

    {% image report.img my_app.Large %}
 
then visit the page, the app will generate a ''Large' reform to the spec given in the filter.

The tag guess can guess the app from the context. So,

     {% image report.img Large %}

Will guess the filter is in whater app the context says the view comes from.

The tag accpts keyword parameters which become HTML attrributes,

     {% image report.img Large class="report-figure" title="" %}

renders similar to,

    <img alt="results-table image" class="report-figure" src="/media/reforms/report-report_large.png">



### Data search by title
There is a tag to find images by title. Sometimes this will be useful, for fixed or temporary decoration/banners etc. However, it uses a database query,

        {{ image-tag-by-title image.Large titleOfImage }}
        <caption>{{ page.img,title }}</caption>

While this may be useful at times, especially for fixed logos or banners, it is unnecessary if you are passing a model through a context,


### Filters from other apps
You can borrow filter collections from other apps. Use the module path and filter classname,

    {% image "urban_decay" different_app.filter_name  %} 

But try not to create a tangle between your apps. You would not do that with CSS or other similar resources. Store general filters in a central location, and namespace them.


## Settings
Images accepts settings. They look like the Django template settings,

    IMAGES = [
        {
            #'MAX_UPLOAD_SIZE': 1,
            'APP_DIRS': True,
            # 'MEDIA_SUBPATH_ORIGINALS':
            # 'MEDIA_SUBPATH_REFORMS':
        'AUTO_DELETE': True,
        'REFORMS': [
            #'FORMAT_OVERRIDE': 'jpg',
            #'JPEG_QUALITY': 28,
            'TRUNCATE_PATHS': True,
        ],
            'MODULES': [
                        "someSiteName",
            ],
        },
    ]


### General settings
MAX_UPLOAD_SIZE
If not set or None, any size allowed. In MB. Fractions allowed.

APP_DIRS
Defines if 'image_filters.py' files will be sought in apps. If false, the app only uses filters defined in the core app.

MODULES
Defines extra places to put modules. The above example suggests a site-wide filter collection in the site directory, same as the site-wide template and CSS collections most Djangos have in the same directory. The setting takes module paths, not filepaths, because filter files are live code.

AUTO_DELETE
When Django started, AFAIK, when models were deleted, attached files were deleted. But default strategy has changed, and now Django will not delete files. They stay in storage, even if untracked.

Deleting files when the model is deleted has downsides, but suits the use-cases of this app. The default of this app is like Django, it will not delete files. But this setting allows you to use clean-on-delete.

You may have noticed in Admin that the app offers a switch to set policy by image. Local settings win---the per-image setting overrides the general setting. For example, you may decide to generally erase files when models are deleted. But if you want to set an image against deletion---for example, a banner, a logo or a generic product photo---you can set that image to persist.


### Reform settings
FORMAT_OVERRIDE
Set a preferred image format. Locality wins. If a filter sets an 'iformat' attribute, that wins. After, if this site-wide setting is present, it wins. After, the filter will attempt to make the file in whatever format it originally detected.

JPEG_QUALITY
Quality of reform JPGs. Basic is '85' of '100', which is high quality. You can go down to '28', say, and get a vast reduction in file sizes.

Locality wins. If a filter sets a 'jpeg_quality' attribute, that wins. After, if this site-wide setting is present, it wins. Otherwise, the quality defaults to '85'.

TRUNCATE_PATHS
Truncate filepaths. This is usually done by truncating the length of filenames (which can become very long on the web). This is because Django limits filepath lengths to 100 chars, to fit in the database fields on FileFields (which must declare length), and to maintain compatibility with some filesystems. Default True. If you switch this setting off, be aware you will also need to expicitly declare longer db fields.


# Other usages
 but for resons of ecomomy, Django doesn't automatically use full clean.. This to thoroughtly check the slug in a 

 So maybe a DetailView,

    class ArticleDetailView(DetailView):
        model = Article
        context_object_name = 'article'
        
Then, it's a waste of the Wagtail setup, but you can summon the original in a template  as simply as,

        {{ article.img.img_tag }}
        <caption>{{ article.img,title }}</caption>

# Types of image
No SVG. Pillow can't pass them over.

 Widths, heights and bytesize of original images are recorded, in case the storage media is not local files but cloud provision.


## Templated HTML and URLs/Filepaths
The app uses the URL attribute of the FileFields to generate HTML 'src' (not the filepath). So it should keep working if you swap storage backends or, at least, keep responding an a Django-like way.


## Forms
There's nothing special about using the Image model in forms. Stock Django. Use the model via Django admin or Model forms. For your own forms, the Image model contains some extra validators, but a call to is_valid() will run them.

  
# Credits
I take little credit for the upload and storage code. It was ripped from the Wagtail CMS. Though I have responsibility for how I have treated the code.

[Wagtail documentation](https://docs.wagtail.io/en/v2.8.1/advanced_topics/images/index.html)


##############
The app is designed for images, so of limited use for other documents and media. It won't be useful for a large number of images, for that you will need to abandon use of Django admin. It is limited for use with a small numbers of images, because you may want more help with image previews and gallery handling. It can not be used to offer users image processing options.

